<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PCB Pinout Creator v24.3 (Image Resize Panel)</title>
    <style>
        :root {
            --editor-bg: #333;
            --panel-bg: #ffffff;
            --border-color: #cccccc;
            --shadow-color: rgba(0,0,0,0.15);
            --text-color: #333333;
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --selection-border: #ff5722;
            --image-selection-color: #007bff;
            --group-selection-color: #9c27b0; /* Purple for groups */
        }

        /* --- MAIN LAYOUT & PANELS --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            margin: 0;
            height: 100vh;
            background-color: var(--editor-bg);
            color: var(--text-color);
            overflow: hidden;
        }
        
        * { box-sizing: border-box; }

        .side-panel {
            width: 280px;
            padding: 20px;
            background-color: var(--panel-bg);
            box-shadow: 0 0 10px var(--shadow-color);
            z-index: 20;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .side-panel h2, .side-panel h3 {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            margin-bottom: 15px;
        }
        .side-panel h2:first-child, .side-panel h3:first-child {
            margin-top: 0;
            border-top: none;
            padding-top: 0;
        }
        
        .panel-section {
             display: none; /* Hidden by default, controlled by JS */
        }

        /* --- GENERIC CONTROLS --- */
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-weight: 600; font-size: 0.9em; }
        .control-group input[type="text"], .control-group input[type="number"] { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .control-group input[type="color"] { width: 100%; height: 40px; padding: 2px; border: 1px solid var(--border-color); background: none; cursor: pointer; }
        button { width: 100%; padding: 10px; background-color: var(--primary-color); color: white; border: none; border-radius: 4px; font-size: 1em; cursor: pointer; transition: background-color 0.2s; margin-top: 5px; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        button.danger { background-color: #dc3545; }
        button.danger:hover { background-color: #c82333; }

        .tool-button {
            background-color: var(--secondary-color);
        }
        .tool-button:hover {
            background-color: #5a6268;
        }

        .tool-subdivision {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            margin-top: 5px;
        }
         .tool-subdivision button {
            font-size: 0.9em;
            padding: 8px;
            background-color: #868e96;
         }
        .tool-subdivision .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; }

        /* --- EDITOR AREA & ARTBOARD --- */
        #editor-area { flex-grow: 1; position: relative; overflow: hidden; cursor: default; }
        #editor-area.panning { cursor: grabbing; }
        #artboard { position: absolute; background-color: #FFFFFF; box-shadow: 0 0 20px rgba(0,0,0,0.5); transform-origin: 0 0; overflow: hidden; }
        .artboard-resize-handle { position: absolute; width: 12px; height: 12px; background-color: var(--primary-color); border: 2px solid white; border-radius: 2px; z-index: 150; bottom: -6px; right: -6px; cursor: se-resize; }
        
        /* --- IMAGE & SELECTION STYLES --- */
        .image-wrapper { position: absolute; cursor: grab; border: 2px dashed transparent; transform-origin: center center; } /* Added transform-origin */
        .image-wrapper.selected { border-color: var(--image-selection-color); z-index: 50; }
        .image-wrapper img { display: block; width: 100%; height: 100%; pointer-events: none; }
        .image-wrapper .image-resize-handle { position: absolute; width: 10px; height: 10px; background: white; border: 1px solid #333; bottom: -5px; right: -5px; cursor: se-resize; display: none; }
        .image-wrapper.selected .image-resize-handle { display: block; }
        #selection-box { position: absolute; border: 1px dashed var(--primary-color); background-color: rgba(0, 123, 255, 0.2); z-index: 1000; display: none; }
        
        /* --- GROUP STYLES --- */
        .group-wrapper { position: absolute; border: 2px dashed transparent; cursor: grab; }
        .group-wrapper.selected { border-color: var(--group-selection-color); z-index: 40; }
        
        /* --- MULTI-FUNCTION PIN STYLES --- */
        .pin { position: absolute; display: flex; align-items: stretch; border: 1px solid #aaa; border-radius: 4px; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); cursor: grab; font-size: 14px; user-select: none; z-index: 10; width: max-content; height: var(--pin-grosor, 22px); }
        .pin.selected { border: 2px solid var(--selection-border); z-index: 100; }
        .pin-id { display: flex; justify-content: center; align-items: center; padding: 6px 10px; font-weight: bold; color: white; background-color: #777; border-radius: 3px 0 0 3px; }
        .pin.vertical { flex-direction: column; height: max-content; width: var(--pin-grosor, 22px); }
        .pin.vertical .pin-id { border-radius: 3px 3px 0 0; width: 100%; }
        .pin.vertical .pin-id span { writing-mode: vertical-rl; transform: rotate(180deg); text-orientation: mixed; }
        .pin.flipped { flex-direction: row-reverse; }
        .pin.flipped .pin-id { border-radius: 0 3px 3px 0; }
        .pin.vertical.flipped { flex-direction: column-reverse; }
        .pin.vertical.flipped .pin-id { border-radius: 0 0 3px 3px; }
        .pin.vertical.flipped .pin-label-container { border-radius: 3px 3px 0 0; }
        .pin-label-container { display: flex; flex-direction: row; align-items: stretch; background-color: #f0f0f0; border-radius: 0 3px 3px 0; overflow: hidden; width: max-content; }
        .pin-function { display: flex; align-items: center; justify-content: center; padding: 0 10px; white-space: nowrap; border-right: 1px solid rgba(0,0,0,0.1); color: #333; }
        .pin-function:last-child { border-right: none; }
        .pin.vertical .pin-label-container { flex-direction: column; height: max-content; width: 100%; }
        .pin.vertical .pin-function { border-right: none; border-bottom: 1px solid rgba(0,0,0,0.1); padding: 10px 0; width: 100%; }
        .pin.vertical .pin-function:last-child { border-bottom: none; }
        .pin.vertical .pin-function span { writing-mode: vertical-rl; transform: rotate(180deg); text-orientation: mixed; }

        /* --- FUNCTION EDITOR (LEFT PANEL) --- */
        .function-editor-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; background-color: #f9f9f9; padding: 8px; border-radius: 4px; }
        .function-editor-row input[type="text"] { flex-grow: 1; }
        .function-editor-row input[type="color"] { width: 32px; height: 32px; padding: 2px; flex-shrink: 0; border: 1px solid var(--border-color); }
        .function-editor-row .delete-function-btn { background-color: #dc3545; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 12px; line-height: 24px; padding: 0; flex-shrink: 0; cursor: pointer; margin-top: 0; }
    </style>
</head>
<body>

    <div id="left-properties-panel" class="side-panel">
        
        <div id="project-properties" class="panel-section">
            <h2>File</h2>
            <div class="control-group"><button id="save-project-btn">Save Project (.pop)</button></div>
            <div class="control-group">
                <button id="load-project-btn">Load Project (.pop)</button>
                <input type="file" id="project-loader" accept=".pop,.json" style="display: none;">
            </div>
            <div class="control-group"><button id="export-png-btn">Export as PNG</button></div>

            <h2>Artboard</h2>
            <div class="control-group"><label for="artboard-width">Width (px)</label><input type="number" id="artboard-width" value="800" min="10"></div>
            <div class="control-group"><label for="artboard-height">Height (px)</label><input type="number" id="artboard-height" value="600" min="10"></div>
            <div class="control-group"><label for="artboard-bg-color">Background Color</label><input type="color" id="artboard-bg-color" value="#FFFFFF"></div>
        </div>

        <div id="pin-properties" class="panel-section">
            <h2>Pin Properties</h2>
            <div class="control-group"><label for="pin-thickness-input">Pin Thickness (px)</label><input type="number" id="pin-thickness-input" min="10" placeholder="22"></div>
            <div class="control-group"><label for="pin-id-text">Pin Label (e.g., P1)</label><input type="text" id="pin-id-text"></div>
            
            <h3>Functions</h3>
            <div id="pin-functions-list"></div>
            <div class="control-group"><button id="add-function-btn" class="tool-button">+ Add Function</button></div>
        </div>

        <div id="image-properties" class="panel-section">
            <h2>Image Properties</h2>
            <div class="control-group"><label for="image-width-input">Width (px)</label><input type="number" id="image-width-input" min="1"></div>
            <div class="control-group"><label for="image-height-input">Height (px)</label><input type="number" id="image-height-input" min="1"></div>
        </div>
         
        <div id="generic-properties" class="panel-section">
            <h2>Selection Properties</h2>
            <p>Multiple items or a group is selected.</p>
            <p>Common properties will be displayed here.</p>
        </div>

    </div>

    <div id="editor-area">
        <div id="selection-box"></div>
        <div id="artboard"><div class="artboard-resize-handle"></div></div>
    </div>

    <div id="right-toolbar-panel" class="side-panel">
        <h2>Tools</h2>

        <div class="control-group">
            <button id="add-image-btn" class="tool-button">Add Image</button>
            <input type="file" id="image-loader" accept="image/*" style="display: none;">
        </div>
        <div class="control-group">
            <button id="add-header-btn" class="tool-button">Add Header</button>
        </div>

        <div id="group-tool" class="control-group" style="display: none;">
            <button id="group-btn" class="tool-button">Group</button>
        </div>
        <div id="ungroup-tool" class="control-group" style="display: none;">
            <button id="ungroup-btn" class="tool-button">Ungroup</button>
        </div>
        <div id="align-tool" class="control-group" style="display: none;">
            <label>Align</label>
            <div class="tool-subdivision">
                <div class="tool-grid">
                    <button id="align-left-btn" title="Align Left">LEFT</button>
                    <button id="align-vcenter-btn" title="Align Vertical Centers">V-C</button>
                    <button id="align-right-btn" title="Align Right">RIGHT</button>
                    <button id="align-top-btn" title="Align Top">TOP</button>
                    <button id="align-hcenter-btn" title="Align Horizontal Centers">H-C</button>
                    <button id="align-bottom-btn" title="Align Bottom">BTM</button>
                </div>
            </div>
        </div>
        <div id="space-v-tool" class="control-group" style="display: none;">
             <button id="tidy-v-btn" class="tool-button">Arrange with spacing (Vertical)</button>
        </div>
        <div id="space-h-tool" class="control-group" style="display: none;">
            <button id="tidy-h-btn" class="tool-button">Arrange with spacing (Horizontal)</button>
        </div>
        <div id="rotate-tool" class="control-group" style="display: none;">
            <button id="rotate-selection-btn" class="tool-button">Rotate 90Â°</button>
        </div>
        <div id="mirror-tool" class="control-group" style="display: none;">
            <button id="flip-selection-btn" class="tool-button">Flip / Mirror</button>
        </div>
        
        <div id="delete-tool" class="control-group" style="display: none; margin-top: 30px;">
             <button id="delete-selection-btn" class="danger">Delete Selection</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- STATE & ELEMENT REFERENCES ---
        const editorArea = document.getElementById('editor-area');
        const artboard = document.getElementById('artboard');
        const selectionBox = document.getElementById('selection-box');
        
        let selectionGroup = [];
        let viewScale = 1, viewTranslateX = 0, viewTranslateY = 0;
        let isPanning = false, isDragging = false, isSelecting = false, isResizingArtboard = false, isResizingImage = false;
        let startX, startY, imageStartWidth, imageStartHeight, imageAspectRatio;
        let dragOffsets = new Map();

        // --- UI PANEL REFERENCES ---
        const leftPanel = {
            project: document.getElementById('project-properties'),
            pin: document.getElementById('pin-properties'),
            image: document.getElementById('image-properties'),
            generic: document.getElementById('generic-properties'),
        };
        const rightToolbar = {
            group: document.getElementById('group-tool'),
            ungroup: document.getElementById('ungroup-tool'),
            align: document.getElementById('align-tool'),
            spaceV: document.getElementById('space-v-tool'),
            spaceH: document.getElementById('space-h-tool'),
            rotate: document.getElementById('rotate-tool'),
            mirror: document.getElementById('mirror-tool'),
            delete: document.getElementById('delete-tool'),
        };

        // --- UI CONTROL REFERENCES ---
        const artboardWidthInput = document.getElementById('artboard-width');
        const artboardHeightInput = document.getElementById('artboard-height');
        const artboardBgColorInput = document.getElementById('artboard-bg-color');
        const imageLoader = document.getElementById('image-loader');
        const addImageBtn = document.getElementById('add-image-btn');
        const addHeaderBtn = document.getElementById('add-header-btn');
        const exportPngBtn = document.getElementById('export-png-btn');
        const saveProjectBtn = document.getElementById('save-project-btn');
        const loadProjectBtn = document.getElementById('load-project-btn');
        const projectLoader = document.getElementById('project-loader');
        const deleteSelectionBtn = document.getElementById('delete-selection-btn');
        const pinThicknessInput = document.getElementById('pin-thickness-input');
        const pinIdTextInput = document.getElementById('pin-id-text');
        const pinFunctionsList = document.getElementById('pin-functions-list');
        const addFunctionBtn = document.getElementById('add-function-btn');
        const imageWidthInput = document.getElementById('image-width-input');
        const imageHeightInput = document.getElementById('image-height-input');
        const groupBtn = document.getElementById('group-btn');
        const ungroupBtn = document.getElementById('ungroup-btn');

        /**
         * Initializes the application, sets up event listeners, and configures the initial view.
         */
        function initializeApp() {
            addEventListeners();
            setArtboardSize(artboardWidthInput.value, artboardHeightInput.value);
            artboard.style.backgroundColor = artboardBgColorInput.value;
            centerArtboard();
            updateUI(); // Initial UI state setup
        }

        /**
         * Centralizes all event listener assignments.
         */
        function addEventListeners() {
            // Left Panel Controls
            artboardWidthInput.addEventListener('input', onArtboardSizeInput);
            artboardHeightInput.addEventListener('input', onArtboardSizeInput);
            artboardBgColorInput.addEventListener('input', (e) => { artboard.style.backgroundColor = e.target.value; });
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', () => projectLoader.click());
            projectLoader.addEventListener('change', loadProject);
            exportPngBtn.addEventListener('click', saveArtboardAsImage);
            pinThicknessInput.addEventListener('input', () => setPinThickness(selectionGroup, pinThicknessInput.value));
            pinIdTextInput.addEventListener('input', (e) => { if (selectionGroup.length === 1 && selectionGroup[0].classList.contains('pin')) { selectionGroup[0].querySelector('.pin-id span').textContent = e.target.value; }});
            addFunctionBtn.addEventListener('click', handleAddFunction);
            imageWidthInput.addEventListener('input', onImageSizeInput);
            imageHeightInput.addEventListener('input', onImageSizeInput);

            // Right Panel (Toolbar) Controls
            addImageBtn.addEventListener('click', () => imageLoader.click());
            imageLoader.addEventListener('change', onImageLoad);
            addHeaderBtn.addEventListener('click', () => { 
                const numPins = prompt("How many pins does the header have?", "8");
                if (numPins && !isNaN(numPins)) {
                     addHeader(parseInt(numPins), 1);
                }
            });
            groupBtn.addEventListener('click', groupSelection);
            ungroupBtn.addEventListener('click', ungroupSelection);
            document.getElementById('align-left-btn').addEventListener('click', () => alignElements('left'));
            document.getElementById('align-right-btn').addEventListener('click', () => alignElements('right'));
            document.getElementById('align-top-btn').addEventListener('click', () => alignElements('top'));
            document.getElementById('align-bottom-btn').addEventListener('click', () => alignElements('bottom'));
            document.getElementById('align-vcenter-btn').addEventListener('click', () => alignElements('vcenter'));
            document.getElementById('align-hcenter-btn').addEventListener('click', () => alignElements('hcenter'));
            document.getElementById('tidy-h-btn').addEventListener('click', () => tidyElements('horizontal'));
            document.getElementById('tidy-v-btn').addEventListener('click', () => tidyElements('vertical'));
            document.getElementById('rotate-selection-btn').addEventListener('click', rotateSelection);
            document.getElementById('flip-selection-btn').addEventListener('click', flipSelection);
            deleteSelectionBtn.addEventListener('click', deleteSelected);

            // Editor Area and Global Event Listeners
            artboard.querySelector('.artboard-resize-handle').addEventListener('mousedown', onResizeArtboardMouseDown);
            editorArea.addEventListener('mousedown', onEditorMouseDown);
            editorArea.addEventListener('wheel', onEditorWheel, { passive: false });
            window.addEventListener('keydown', handleKeyPress);
            window.addEventListener('keyup', handleKeyRelease);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // --- CORE UI LOGIC ---

        /**
         * Updates the entire user interface based on the current selection.
         * It shows/hides the appropriate panels and tools in the left and right sidebars.
         */
        function updateUI() {
            const selectionSize = selectionGroup.length;
            const isSingleSelection = selectionSize === 1;
            const isMultiSelection = selectionSize > 1;
            const hasSelection = selectionSize > 0;
            
            const selectedElement = isSingleSelection ? selectionGroup[0] : null;
            const isPinSelected = isSingleSelection && selectedElement.classList.contains('pin');
            const isImageSelected = isSingleSelection && selectedElement.classList.contains('image-wrapper');
            const hasGroupsInSelection = selectionGroup.some(el => el.classList.contains('group-wrapper'));

            // --- Left Panel Logic ---
            leftPanel.project.style.display = hasSelection ? 'none' : 'block';
            leftPanel.pin.style.display = isPinSelected ? 'block' : 'none';
            leftPanel.image.style.display = isImageSelected ? 'block' : 'none';
            leftPanel.generic.style.display = isMultiSelection || (isSingleSelection && !isPinSelected && !isImageSelected) ? 'block' : 'none';

            if (isPinSelected) {
                updatePinEditorPanel(selectedElement);
            }
            if (isImageSelected) {
                updateImageEditorPanel(selectedElement);
            }

            // --- Right Toolbar Logic ---
            rightToolbar.group.style.display = isMultiSelection ? 'block' : 'none';
            rightToolbar.ungroup.style.display = hasSelection && hasGroupsInSelection ? 'block' : 'none';
            rightToolbar.align.style.display = isMultiSelection ? 'block' : 'none';
            rightToolbar.spaceV.style.display = isMultiSelection ? 'block' : 'none';
            rightToolbar.spaceH.style.display = isMultiSelection ? 'block' : 'none';
            rightToolbar.rotate.style.display = hasSelection ? 'block' : 'none';
            rightToolbar.mirror.style.display = hasSelection ? 'block' : 'none';
            rightToolbar.delete.style.display = hasSelection ? 'block' : 'none';
        }
        
        /**
         * Populates the pin editor panel with the properties of the selected pin.
         * @param {HTMLElement} pin The selected pin element.
         */
        function updatePinEditorPanel(pin) {
            if (!pin || !pin.classList.contains('pin')) return; 
            pinIdTextInput.value = pin.querySelector('.pin-id span').textContent;
            pinThicknessInput.value = (pin.style.getPropertyValue('--pin-grosor') || '22px').replace('px', '');

            pinFunctionsList.innerHTML = '';
            const functions = pin.querySelectorAll('.pin-function');
            functions.forEach((funcEl) => {
                const text = funcEl.querySelector('span').textContent;
                const color = rgbToHex(funcEl.style.backgroundColor);
                const row = document.createElement('div');
                row.className = 'function-editor-row';
                row.innerHTML = `<input type="text" value="${text}"><input type="color" value="${color}"><button class="delete-function-btn">X</button>`;
                pinFunctionsList.appendChild(row);

                const textInput = row.querySelector('input[type="text"]');
                const colorInput = row.querySelector('input[type="color"]');
                const deleteBtn = row.querySelector('.delete-function-btn');

                textInput.addEventListener('input', (e) => { funcEl.querySelector('span').textContent = e.target.value; });
                colorInput.addEventListener('input', (e) => { funcEl.style.backgroundColor = e.target.value; });
                deleteBtn.addEventListener('click', () => {
                    if (pin.querySelectorAll('.pin-function').length > 1) {
                        funcEl.remove();
                        updatePinEditorPanel(pin);
                    } else {
                        alert("A pin must have at least one function.");
                    }
                });
            });
        }
        
        /**
         * Populates the image editor panel with the dimensions of the selected image.
         * @param {HTMLElement} imageWrapper The selected image wrapper element.
         */
        function updateImageEditorPanel(imageWrapper) {
            if (!imageWrapper || !imageWrapper.classList.contains('image-wrapper')) return;
            // Avoid updating the input if the user is currently typing in it
            if(document.activeElement !== imageWidthInput) {
                imageWidthInput.value = Math.round(imageWrapper.offsetWidth);
            }
            if(document.activeElement !== imageHeightInput) {
                imageHeightInput.value = Math.round(imageWrapper.offsetHeight);
            }
        }

        /**
         * Adds a new function to the currently selected pin.
         */
        function handleAddFunction() {
            if (selectionGroup.length !== 1 || !selectionGroup[0].classList.contains('pin')) return;
            const pin = selectionGroup[0];
            const container = pin.querySelector('.pin-label-container');
            const newFunc = document.createElement('div');
            newFunc.className = 'pin-function';
            newFunc.style.backgroundColor = '#ffffff';
            newFunc.innerHTML = `<span>New Function</span>`;
            container.appendChild(newFunc);
            updatePinEditorPanel(pin);
        }

        // --- ELEMENT MANIPULATION LOGIC ---

        function groupSelection() { if (selectionGroup.length <= 1) return; const groupWrapper = document.createElement('div'); groupWrapper.className = 'group-wrapper'; const rects = selectionGroup.map(el => ({ left: el.offsetLeft, top: el.offsetTop, right: el.offsetLeft + el.offsetWidth, bottom: el.offsetTop + el.offsetHeight })); const minX = Math.min(...rects.map(r => r.left)); const minY = Math.min(...rects.map(r => r.top)); const maxX = Math.max(...rects.map(r => r.right)); const maxY = Math.max(...rects.map(r => r.bottom)); groupWrapper.style.left = `${minX}px`; groupWrapper.style.top = `${minY}px`; groupWrapper.style.width = `${maxX - minX}px`; groupWrapper.style.height = `${maxY - minY}px`; selectionGroup.forEach(el => { el.style.left = `${el.offsetLeft - minX}px`; el.style.top = `${el.offsetTop - minY}px`; groupWrapper.appendChild(el); }); artboard.appendChild(groupWrapper); groupWrapper.addEventListener('mousedown', handleElementSelection); deselectAll(); selectionGroup = [groupWrapper]; groupWrapper.classList.add('selected'); updateUI(); }
        function ungroupSelection() { const groupsToUngroup = selectionGroup.filter(el => el.classList.contains('group-wrapper')); if (groupsToUngroup.length === 0) return; const releasedElements = []; groupsToUngroup.forEach(group => { const groupLeft = group.offsetLeft; const groupTop = group.offsetTop; while(group.firstChild) { const child = group.firstChild; child.style.left = `${child.offsetLeft + groupLeft}px`; child.style.top = `${child.offsetTop + groupTop}px`; artboard.appendChild(child); releasedElements.push(child); } group.remove(); }); deselectAll(); selectionGroup = releasedElements; selectionGroup.forEach(el => el.classList.add('selected')); updateUI(); }
        function createPinElement(idText, labelText, x, y) { const pin = document.createElement('div'); pin.className = 'pin'; pin.style.left = `${x}px`; pin.style.top = `${y}px`; pin.innerHTML = `<div class="pin-id" style="background-color: #777;"><span>${idText}</span></div><div class="pin-label-container"><div class="pin-function" style="background-color: #ffffff;"><span>${labelText}</span></div></div>`; artboard.appendChild(pin); pin.addEventListener('mousedown', handleElementSelection); return pin; }
        function addHeader(numPins = 8, numRows = 1) { const startX = 20, startY = 20, pinSpacingY = 40, rowSpacingX = 250; let addedPins = []; for (let row = 0; row < numRows; row++) { for (let i = 0; i < numPins; i++) { const newPin = createPinElement(`P${row * numPins + i}`, 'FUNCTION', startX + row * rowSpacingX, startY + i * pinSpacingY); addedPins.push(newPin); } } deselectAll(); selectionGroup = addedPins; addedPins.forEach(p => p.classList.add('selected')); updateUI(); }
        function setPinThickness(pins, value) { if (pins.length === 0) return; const thickness = parseInt(value); const styleValue = (!isNaN(thickness) && thickness > 0) ? `${thickness}px` : null; pins.forEach(el => { if (el.classList.contains('pin')) { el.style.setProperty('--pin-grosor', styleValue); } }); }
        function tidyElements(mode) { if (selectionGroup.length < 2) return; const gapInput = prompt(`Enter the spacing in pixels for the ${mode} arrangement:`, "10"); const gap = parseInt(gapInput) || 0; if (mode === 'vertical') { const sorted = selectionGroup.slice().sort((a,b) => a.offsetTop - b.offsetTop); const avgLeft = sorted.reduce((sum, el) => sum + el.offsetLeft, 0) / sorted.length; let currentTop = sorted[0].offsetTop; sorted.forEach(el => { el.style.left = `${avgLeft}px`; el.style.top = `${currentTop}px`; currentTop += el.offsetHeight + gap; }); } else { const sorted = selectionGroup.slice().sort((a,b) => a.offsetLeft - b.offsetLeft); const avgTop = sorted.reduce((sum, el) => sum + el.offsetTop, 0) / sorted.length; let currentLeft = sorted[0].offsetLeft; sorted.forEach(el => { el.style.top = `${avgTop}px`; el.style.left = `${currentLeft}px`; currentLeft += el.offsetWidth + gap; }); } }
        function deleteSelected() { selectionGroup.forEach(el => el.remove()); deselectAll(); }
        
        /**
         * Applies the correct visual transformation to an element based on its data-rotation attribute.
         * @param {HTMLElement} el The element to transform.
         */
        function applyElementTransform(el) {
            const rotation = parseInt(el.dataset.rotation || 0);
            if (el.classList.contains('pin')) {
                // For pins, rotation is handled by swapping classes
                el.classList.remove('vertical', 'flipped');
                if (rotation === 90) {
                    el.classList.add('vertical');
                } else if (rotation === 180) {
                    el.classList.add('flipped');
                } else if (rotation === 270) {
                    el.classList.add('vertical', 'flipped');
                }
            } else if (el.classList.contains('image-wrapper')) {
                // For images, use CSS transform
                el.style.transform = `rotate(${rotation}deg)`;
            }
        }

        /**
         * Rotates the selected elements by 90 degrees progressively.
         */
        function rotateSelection() {
            if (selectionGroup.length < 1) return;
            selectionGroup.forEach(el => {
                let currentRotation = parseInt(el.dataset.rotation || 0);
                let newRotation = (currentRotation + 90) % 360;
                el.dataset.rotation = newRotation;
                applyElementTransform(el);
            });
        }

        /**
         * Flips (rotates by 180 degrees) the selected elements.
         */
        function flipSelection() {
            if (selectionGroup.length < 1) return;
            selectionGroup.forEach(el => {
                let currentRotation = parseInt(el.dataset.rotation || 0);
                let newRotation = (currentRotation + 180) % 360;
                el.dataset.rotation = newRotation;
                applyElementTransform(el);
            });
        }

        function createImageElement(file, offset = 0) { const wrapper = document.createElement('div'); wrapper.className = 'image-wrapper'; const img = document.createElement('img'); const handle = document.createElement('div'); handle.className = 'image-resize-handle'; wrapper.append(img, handle); artboard.appendChild(wrapper); wrapper.addEventListener('mousedown', handleElementSelection); const reader = new FileReader(); reader.onload = (e) => { img.src = e.target.result; img.onload = () => { const aspectRatio = img.naturalWidth / img.naturalHeight; const initialWidth = 250; wrapper.style.width = `${initialWidth}px`; wrapper.style.height = `${initialWidth / aspectRatio}px`; wrapper.style.left = `${50 + offset * 20}px`; wrapper.style.top = `${50 + offset * 20}px`; deselectAll(); selectionGroup = [wrapper]; wrapper.classList.add('selected'); updateUI(); }; }; reader.readAsDataURL(file); }
        function onImageLoad(e) { const files = e.target.files; if (!files) return; deselectAll(); for (let i = 0; i < files.length; i++) { createImageElement(files[i], i); } e.target.value = ''; }
        
        /**
         * Handles resizing an image from the left panel inputs.
         */
        function onImageSizeInput() {
            if (selectionGroup.length !== 1 || !selectionGroup[0].classList.contains('image-wrapper')) return;
            const imageWrapper = selectionGroup[0];

            const newWidth = parseInt(imageWidthInput.value);
            if (!isNaN(newWidth) && newWidth > 0) {
                imageWrapper.style.width = `${newWidth}px`;
            }

            const newHeight = parseInt(imageHeightInput.value);
            if (!isNaN(newHeight) && newHeight > 0) {
                imageWrapper.style.height = `${newHeight}px`;
            }
        }
        
        // --- SELECTION HANDLING ---

        function deselectAll() { selectionGroup.forEach(p => p.classList.remove('selected')); selectionGroup = []; updateUI(); }
        function handleElementSelection(e) { e.stopPropagation(); if (e.target.classList.contains('image-resize-handle')) { isResizingImage = true; startX = e.clientX; startY = e.clientY; const wrapper = e.currentTarget; imageStartWidth = wrapper.offsetWidth; imageStartHeight = wrapper.offsetHeight; const img = wrapper.querySelector('img'); imageAspectRatio = img.naturalWidth / img.naturalHeight; return; } let selectableTarget = e.currentTarget; while (selectableTarget.parentElement && selectableTarget.parentElement.id !== 'artboard') { selectableTarget = selectableTarget.parentElement; } const isMultiSelect = e.ctrlKey || e.metaKey; const isTargetAlreadySelected = selectableTarget.classList.contains('selected'); if (!isMultiSelect && !isTargetAlreadySelected) { deselectAll(); } const index = selectionGroup.indexOf(selectableTarget); if (isMultiSelect) { if (index > -1) { selectionGroup.splice(index, 1); selectableTarget.classList.remove('selected'); } else { selectionGroup.push(selectableTarget); selectableTarget.classList.add('selected'); } } else if (index === -1) { selectionGroup.push(selectableTarget); selectableTarget.classList.add('selected'); } updateUI(); isDragging = true; startX = e.clientX; startY = e.clientY; dragOffsets.clear(); selectionGroup.forEach(el => { dragOffsets.set(el, { x: el.offsetLeft, y: el.offsetTop }); }); }
        function checkSelectionBox(boxRect) { deselectAll(); const newSelection = []; const allSelectable = artboard.querySelectorAll('.pin, .image-wrapper, .group-wrapper'); allSelectable.forEach(el => { if (el.parentElement.id === 'artboard') { const elRect = el.getBoundingClientRect(); const inBox = !(boxRect.right < elRect.left || boxRect.left > elRect.right || boxRect.bottom < elRect.top || boxRect.top > elRect.bottom); if (inBox) { newSelection.push(el); el.classList.add('selected'); } } }); selectionGroup = newSelection; }

        // --- ARTBOARD & VIEWPORT MANAGEMENT ---

        function setArtboardSize(width, height) { artboard.style.width = `${width}px`; artboard.style.height = `${height}px`; if (document.activeElement !== artboardWidthInput) artboardWidthInput.value = Math.round(width); if (document.activeElement !== artboardHeightInput) artboardHeightInput.value = Math.round(height); }
        function centerArtboard() { const artboardW = artboard.offsetWidth, artboardH = artboard.offsetHeight; viewTranslateX = (editorArea.clientWidth - artboardW) / 2; viewTranslateY = (editorArea.clientHeight - artboardH) / 2; viewScale = 1; updateViewTransform(); }
        function onArtboardSizeInput() { const newWidth = parseInt(artboardWidthInput.value) || artboard.offsetWidth; const newHeight = parseInt(artboardHeightInput.value) || artboard.offsetHeight; setArtboardSize(newWidth, newHeight); }
        function onResizeArtboardMouseDown(e) { e.stopPropagation(); isResizingArtboard = true; startX = e.clientX; startY = e.clientY; let artboardStartWidth = artboard.offsetWidth; let artboardStartHeight = artboard.offsetHeight; function onResizeArtboardMouseMove(ev) { if (!isResizingArtboard) return; const dx = (ev.clientX - startX) / viewScale; const dy = (ev.clientY - startY) / viewScale; setArtboardSize(artboardStartWidth + dx, artboardStartHeight + dy); } function onResizeArtboardMouseUp() { isResizingArtboard = false; document.removeEventListener('mousemove', onResizeArtboardMouseMove); document.removeEventListener('mouseup', onResizeArtboardMouseUp);} document.addEventListener('mousemove', onResizeArtboardMouseMove); document.addEventListener('mouseup', onResizeArtboardMouseUp);}
        function updateViewTransform() { artboard.style.transform = `translate(${viewTranslateX}px, ${viewTranslateY}px) scale(${viewScale})`; }
        function onEditorWheel(e) { e.preventDefault(); const rect = editorArea.getBoundingClientRect(); const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top; const scaleAmount = 1.1, oldScale = viewScale; viewScale = e.deltaY < 0 ? viewScale * scaleAmount : viewScale / scaleAmount; viewTranslateX = mouseX - (mouseX - viewTranslateX) * (viewScale / oldScale); viewTranslateY = mouseY - (mouseY - viewTranslateY) * (viewScale / oldScale); updateViewTransform(); }
        
        // --- MOUSE & KEYBOARD EVENT HANDLERS ---

        function handleKeyPress(e) { const activeEl = document.activeElement; if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return; if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); deleteSelected(); } if (e.key === ' ' && !isPanning) { e.preventDefault(); editorArea.classList.add('panning'); } if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'g' && !e.shiftKey) { e.preventDefault(); groupSelection(); } if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'g') { e.preventDefault(); ungroupSelection(); } }
        function handleKeyRelease(e) { if (e.key === ' ') { editorArea.classList.remove('panning'); } }
        function onEditorMouseDown(e) { if (e.button === 1 || e.key === ' ') { e.preventDefault(); isPanning = true; startX = e.clientX; startY = e.clientY; editorArea.classList.add('panning'); return; } if (e.button === 0) { const target = e.target; if (target === artboard || target === editorArea) { e.preventDefault(); isSelecting = true; deselectAll(); selectionBox.style.display = 'block'; const rect = editorArea.getBoundingClientRect(); startX = e.clientX - rect.left; startY = e.clientY - rect.top; selectionBox.style.left = `${startX}px`; selectionBox.style.top = `${startY}px`; selectionBox.style.width = '0px'; selectionBox.style.height = '0px'; } } }
        function onMouseMove(e) { if (isSelecting) { const rect = editorArea.getBoundingClientRect(); const currentX = e.clientX - rect.left; const currentY = e.clientY - rect.top; selectionBox.style.left = `${Math.min(startX, currentX)}px`; selectionBox.style.top = `${Math.min(startY, currentY)}px`; selectionBox.style.width = `${Math.abs(currentX - startX)}px`; selectionBox.style.height = `${Math.abs(currentY - startY)}px`; } else if (isDragging) { const dx = (e.clientX - startX) / viewScale, dy = (e.clientY - startY) / viewScale; selectionGroup.forEach(el => { const offset = dragOffsets.get(el); if (offset) { el.style.left = `${offset.x + dx}px`; el.style.top = `${offset.y + dy}px`; } }); updateUI(); /* Update panels during drag */ } else if (isPanning) { viewTranslateX += e.clientX - startX; viewTranslateY += e.clientY - startY; startX = e.clientX; startY = e.clientY; updateViewTransform(); } else if (isResizingImage) { const dx = (e.clientX - startX) / viewScale; const newWidth = imageStartWidth + dx; if (newWidth > 20) { selectionGroup[0].style.width = `${newWidth}px`; selectionGroup[0].style.height = `${newWidth / imageAspectRatio}px`; updateUI(); /* Update panels during resize */ } } }
        function onMouseUp(e) { if (isSelecting) { checkSelectionBox(selectionBox.getBoundingClientRect()); updateUI(); } if (isPanning) { editorArea.classList.remove('panning'); } isPanning = isDragging = isSelecting = isResizingArtboard = isResizingImage = false; selectionBox.style.display = 'none'; }
        
        // --- ALIGNMENT & DISTRIBUTION FUNCTIONS ---

        function alignElements(mode) { if (selectionGroup.length < 2) return; let target; switch(mode) { case 'left': target = Math.min(...selectionGroup.map(p => p.offsetLeft)); selectionGroup.forEach(p => p.style.left = `${target}px`); break; case 'right': target = Math.max(...selectionGroup.map(p => p.offsetLeft + p.offsetWidth)); selectionGroup.forEach(p => p.style.left = `${target - p.offsetWidth}px`); break; case 'top': target = Math.min(...selectionGroup.map(p => p.offsetTop)); selectionGroup.forEach(p => p.style.top = `${target}px`); break; case 'bottom': target = Math.max(...selectionGroup.map(p => p.offsetTop + p.offsetHeight)); selectionGroup.forEach(p => p.style.top = `${target - p.offsetHeight}px`); break; case 'hcenter': target = selectionGroup[0].offsetTop + selectionGroup[0].offsetHeight / 2; selectionGroup.forEach(p => p.style.top = `${target - p.offsetHeight / 2}px`); break; case 'vcenter': target = selectionGroup[0].offsetLeft + selectionGroup[0].offsetWidth / 2; selectionGroup.forEach(p => p.style.left = `${target - p.offsetWidth / 2}px`); break; } }

        // --- SAVE, LOAD, & EXPORT FUNCTIONS ---

        function saveProject() { try { const serializeElements = (elementCollection) => { const serialized = []; for (const el of elementCollection) { let obj; if (el.classList.contains('pin')) { obj = { type: 'pin', left: el.offsetLeft, top: el.offsetTop, thickness: el.style.getPropertyValue('--pin-grosor') || null, idText: el.querySelector('.pin-id span').textContent, idColor: rgbToHex(el.querySelector('.pin-id').style.backgroundColor), rotation: el.dataset.rotation || 0, functions: Array.from(el.querySelectorAll('.pin-function')).map(func => ({ text: func.querySelector('span').textContent, color: rgbToHex(func.style.backgroundColor) })) }; } else if (el.classList.contains('image-wrapper')) { const img = el.querySelector('img'); obj = { type: 'image', left: el.offsetLeft, top: el.offsetTop, width: el.offsetWidth, height: el.offsetHeight, imageData: img.src, rotation: el.dataset.rotation || 0 }; } else if (el.classList.contains('group-wrapper')) { obj = { type: 'group', left: el.offsetLeft, top: el.offsetTop, width: el.offsetWidth, height: el.offsetHeight, elements: serializeElements(el.children) }; } if(obj) serialized.push(obj); } return serialized; }; const projectData = { version: '2.1-json', artboard: { width: artboard.offsetWidth, height: artboard.offsetHeight, backgroundColor: artboard.style.backgroundColor }, elements: serializeElements(Array.from(artboard.children).filter(c => !c.classList.contains('artboard-resize-handle'))) }; const projectJSON = JSON.stringify(projectData, null, 2); const blob = new Blob([projectJSON], { type: 'application/json' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = "my_pinout.pop"; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); } catch (error) { console.error("ERROR in saveProject function:", error); alert("An error occurred while trying to save the project. Check the console for more details."); } }
        function loadProject(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const projectData = JSON.parse(e.target.result); rebuildArtboard(projectData); } catch (err) { alert('Error reading file. The file is not a valid JSON project.'); console.error("Error parsing project file:", err); } }; reader.readAsText(file); projectLoader.value = ''; }
        function rebuildArtboard(projectData) { deselectAll(); while (artboard.children.length > 1) { artboard.removeChild(artboard.firstChild); } setArtboardSize(projectData.artboard.width, projectData.artboard.height); artboard.style.backgroundColor = projectData.artboard.backgroundColor; artboardBgColorInput.value = projectData.artboard.backgroundColor; const buildElements = (elementsData, parent) => { for (const data of elementsData) { let el; if (data.type === 'pin') { el = createPinElement(data.idText, '', 0, 0); const pinId = el.querySelector('.pin-id'); const functionsContainer = el.querySelector('.pin-label-container'); pinId.style.backgroundColor = data.idColor; functionsContainer.innerHTML = data.functions.map(f => `<div class="pin-function" style="background-color: ${f.color};"><span>${f.text}</span></div>`).join(''); if (data.thickness) el.style.setProperty('--pin-grosor', data.thickness); } else if (data.type === 'image') { el = document.createElement('div'); el.className = 'image-wrapper'; const img = document.createElement('img'); img.src = data.imageData; const handle = document.createElement('div'); handle.className = 'image-resize-handle'; el.append(img, handle); el.addEventListener('mousedown', handleElementSelection); } else if (data.type === 'group') { el = document.createElement('div'); el.className = 'group-wrapper'; el.addEventListener('mousedown', handleElementSelection); buildElements(data.elements, el); } if (el) { el.style.left = `${data.left}px`; el.style.top = `${data.top}px`; if (data.width) el.style.width = `${data.width}px`; if (data.height) el.style.height = `${data.height}px`; if (data.rotation) { el.dataset.rotation = data.rotation; applyElementTransform(el); } parent.appendChild(el); } } }; buildElements(projectData.elements, artboard); updateUI(); }
        function getEmbeddedCss() { const cssRules = []; for (const sheet of document.styleSheets) { try { if (sheet.cssRules) { for (const rule of sheet.cssRules) { cssRules.push(rule.cssText); } } } catch (e) { console.warn("Could not read CSS rule from stylesheet:", e); } } return cssRules.join('\n'); }
        function saveArtboardAsImage() { deselectAll(); const width = artboard.offsetWidth; const height = artboard.offsetHeight; const artboardHtml = artboard.innerHTML; const embeddedCss = getEmbeddedCss() + ` #artboard { background-color: ${artboard.style.backgroundColor}; }`; const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}"><foreignObject width="100%" height="100%"><div xmlns="http://www.w3.org/1999/xhtml"><style>${embeddedCss}</style>${artboardHtml}</div></foreignObject></svg>`; const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' }); const url = URL.createObjectURL(blob); const img = new Image(); img.onload = () => { const canvas = document.createElement('canvas'); const scale = 2; canvas.width = width * scale; canvas.height = height * scale; const ctx = canvas.getContext('2d'); ctx.scale(scale, scale); ctx.drawImage(img, 0, 0); const link = document.createElement('a'); link.href = canvas.toDataURL('image/png'); link.download = 'pinout-design.png'; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); }; img.onerror = (e) => { console.error("Failed to load SVG as an image.", e); alert("Sorry, there was an error saving the image."); }; img.src = url; }
        function rgbToHex(rgb) { if (!rgb || !rgb.startsWith('rgb')) return '#ffffff'; let [r, g, b] = rgb.match(/\d+/g).map(Number); return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
        
        // --- Initialize The Application ---
        initializeApp();
    });
    </script>
</body>
</html>
